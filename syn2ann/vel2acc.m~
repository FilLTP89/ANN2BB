%% *Velocigram Processing*
% _Editor: Filippo Gatti
% CentraleSupÃ©lec - Laboratoire MSSMat
% Politecnico di Milano - DICA
% Copyright 2016_
%% NOTES
% _vel2acc_: function to differentiate velocigram to get accelerogram
% by applying butterworth filter and detrending.
%% INPUT:
% * _dt (sampling time step)_
% * _thv (input velocigram)_
% * _lfr (corner frequency)_
% * _hfr (cut-off frequency)_
%% OUTPUT:
% * _tha (band-pass filtered acceleration time-history column
% vector)_
% * _thv (velocity time-history column vector)_
% * _thd (displacement time-history column vector)_
function [varargout] = vel2acc(varargin)
    %% *SET-UP*
    % time-step
    dtm = varargin{1};
    % velocigram
    thv = varargin{2}(:);
    % default corner frequency (high-pass filter)
    lfr =.05;
    % default cutoff frequency (low-pass filter)
    hfr = 25;
    % default butterworth order
    bfo = 3;
    % custom corner frequency (high-pass filter)_
    if nargin>=3
        lfr=varargin{3};
    end
    % custom cutoff frequency (low-pass filter)_
    if nargin>=4
        hfr=varargin{4};
    end
    % Nyquist frequency
    fNy = 0.5/dtm;
    if ~isempty(hfr)
        if hfr>fNy
            hfr = fNy;
        end
    end
    
    %% *CREATE BUTTERWORTH FILTER*
    [bfb,bfa,flag] = create_butter_filter(bfo,lfr,hfr,fNy);

    if flag
        %% *PROCESSING VELOCITY*
        disp('--->CORRECTING VELOCITY')
        %
        % _pad definition_
        %
        % number of time steps of original record
        ntm     = numel(thv);
        % number of padding points (Boore&Bommer,2005)
        npd     = ceil(1.5*bfo/min([lfr;hfr]));
        % number of time-steps of padded record
        ntm_pad = ntm + 2*npd;
        %
        % _velocity padding_
        thv_pad = padarray(thv,npd,'both');
        %
        % _velocity base-line correction_
        %
        thv_pad = detrend(thv_pad);
        %
        % _velocity acausal Butterworth filtering_
        %
        thv_pad = filtfilt(bfb,bfa,thv_pad);
        
        %% *CORRECTED DISPLACEMENT TIME INTEGRATION*
        % displacement
        thd_pad = cumtrapz(thv_pad)*dtm;
        %
        % _displacement base-line correction_
        %
        thd_pad = detrend(thd_pad);
        %
        % _displacement cosinus tapering_
        %
        thd_pad = cos_taper(thd_pad);
        % EQUIVALENT: thd = taper_fun(thd,2.5,1,1);
        %
        % _displacement acasual filtering_
        %
        thd_ = filtfilt(bfb,bfa,thd_pad);
    else
        %
        % _time integration_
        %
        thd = cumtrapz(thv)*dtm;
    end
    %% BACK TO ACCELERATION
    % _time differentiation_
    tha(2:ntm_pad-1,1) = (thv(3:ntm_pad,1)-thv(1:ntm_pad-2,1))./(2*dtm);
    tha(1,1) = 0.0;
    tha(ntm_pad,1) = tha(ntm_pad-1,1);
    % _time integration_
    thv = cumtrapz(tha)*dtm;
    thd = cumtrapz(thv)*dtm;
    
    %% *OUTPUT*
    if flag
        varargout{1} = tha(npd+1:ntm+npd,1);
        varargout{2} = thv(npd+1:ntm+npd,1);
        varargout{3} = thd(npd+1:ntm+npd,1);
    else
        varargout{1} = tha(:);
        varargout{2} = thv(:);
        varargout{3} = thd(:);
    end
    return
end
